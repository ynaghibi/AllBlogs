<!DOCTYPE html>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="LyX 2.4.2.1" name="generator"/>
<title>LyX Document</title>
<style>
/* Layout-provided Styles */
div.standard {
	margin-bottom: 2ex;
}
h2.section {
font-weight: bold;
font-size: x-large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: left;

}
dl.description dt { font-weight: bold; }
h3.subsection {
font-weight: bold;
font-size: large;
margin-top: 0.9ex;
margin-bottom: 0.5ex;
text-align: left;

}
div.plain_layout {
text-align: left;

}
div.lyx_code {
font-family: monospace;
margin-top: 0.5ex;
margin-bottom: 0.5ex;
margin-left: 3ex;
margin-right: 3ex;
text-align: left;

}
h4.subsubsection {
font-weight: bold;
font-size: medium;
margin-top: 0.7ex;
margin-bottom: 0.4ex;
text-align: left;

}
h5.paragraph {
font-weight: bold;
font-size: medium;
margin-top: 0.4ex;
text-align: left;

}
ol.enumi   { list-style-type: decimal; }
ol.enumii  { list-style-type: lower-latin; }
ol.enumiii { list-style-type: lower-roman; }
ol.enumiv  { list-style-type: upper-latin; }
div.bibliography {
	margin-left: 2em;
	text-indent: -2em;
}
span.bibitemlabel:before { content: "["; }
span.bibitemlabel:after { content: "] "; }
div.toc {
  margin: 2em 0em;
  border-style: solid;
  border-width: 2px 0px;
  padding: 1em 0em;
}
h2.tochead { font-size: x-large; font-weight: bold; }
div.lyxtoc-0 {
  margin: 2em 0em 0em 0em;
  font-size: xx-large;
  font-weight: bold;
}
div.lyxtoc-1 {
  margin: 1em 0em 0em 0em;
  font-size: x-large;
  font-weight: bold;
}
div.lyxtoc-2 {
  margin: 0.5em 0.1em 0em 1em;
  font-size: large;
  font-weight: normal;
}
div.lyxtoc-3 { margin: 0.2em 0.1em 0em 0.5em; font-size: medium; }
div.lyxtoc-4 { margin: 0em 0.1em 0em 0.5em; }
div.lyxtoc-5 { margin: 0em 0.1em 0em 0.5em; }
div.lyxtoc-6 { margin: 0em 0.1em 0em 0.5em; }
a.tocentry {
  text-decoration: none;
  color: black;
}
a.tocentry:visited { color: black; }
div.float {
	border: 2px solid black;
	text-align: center;
}
div.float-caption {
	text-align: center;
	border: 2px solid black;
	padding: 1ex;
	margin: 1ex;
}



:root {
    --bg-color: #121212;
    --text-color: #e0e0e0;
    --accent-color: #bb86fc;
    --border-color: #333;
    --code-bg: #1e1e1e;
    --item-bullet: #bb86fc;
    --math-color: #f5f5f5;
    --link-color: #82b1ff;
    --link-hover: #bb86fc;
}

body {
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding: 20px;
    max-width: 700px;
    margin: 0 auto;
	 zoom: 140%;
}

math {
    color: var(--math-color);
    margin: 15px 0;
    padding: 10px;
    background-color: #1e1e1e;
    border-radius: 4px;
}

div.lyx_code {
    font-family: 'Consolas', monospace;
    background-color: #252525;
    border-left: 3px solid #bb86fc;
    padding: 12px;
    border-radius: 3px;
    overflow-x: auto;
    font-size: 13px !important;
    line-height: 1.4 !important;
}

.lyx_code_item,
.lyx_code_item span,
.lyx_code_item b,
.lyx_code_item b span {
    color: #e0e0e0 !important;
    font-size: inherit !important;
    font-family: 'Consolas', monospace !important;
    letter-spacing: 0.3px !important;
}

.lyx_code_item b i,
.lyx_code_item i b {
    font-size: inherit !important;
    font-weight: bold !important;
    font-style: italic !important;
}

.toc,
.toc a,
.toc li,
.toc li a {
    color: var(--text-color);
    transition: color 0.2s ease;
}

.toc a:hover,
.toc li a:hover {
    color: var(--link-hover);
    text-decoration: underline;
}

.toc a:visited,
.toc a:active {
    color: var(--link-color);
}

div.float-figure img { 
    cursor: zoom-in; 
    transition: transform 0.3s ease;
}
div.float-figure img:hover {
    transform: scale(2.5);
    cursor: zoom-out;
}
</style>
</head>
<body dir="auto">
<div class="standard" id="magicparlabel-1"> </div>
<div class="standard" id="magicparlabel-9"> </div>
<div class="standard" id="magicparlabel-25">  </div>
<div class="standard" id="magicparlabel-30"><br/></div>
<div class="toc"><h2 class="tochead section">Table of Contents</h2>
<div class="lyxtoc-1">
<div class="lyxtoc-2">
<a class="tocentry" href="#magicparlabel-35">1 Quick Info</a>
</div>
<div class="lyxtoc-2">
<a class="tocentry" href="#magicparlabel-54">2 How to read this guide</a>
</div>
<div class="lyxtoc-2">
<a class="tocentry" href="#magicparlabel-56">3 Machine Learning with Python</a>
<div class="lyxtoc-3">
<a class="tocentry" href="#magicparlabel-63">3.1 First Steps</a>
</div>
<div class="lyxtoc-3">
<a class="tocentry" href="#magicparlabel-477">3.2 Small Project</a>
</div>
</div>
<div class="lyxtoc-2">
<a class="tocentry" href="#magicparlabel-726">References </a><a href="https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/submissions">House Prices - Advanced Regression Techniques</a>
</div>
</div>
</div>
<section>
<h2 class="section" id="magicparlabel-35"><span class="section_label">1</span> Quick Info</h2>
<dl class="description">
<dt class="description_label">Audience:</dt>
<dd class="description_item" id="magicparlabel-36"> This part of the series is made for beginners with basic knowledge in Python programming. You only need to make sure you have Jupyter notebooks and all Python modules installed (see previous part). </dd>
<dt class="description_label">Goal:</dt>
<dd class="description_item" id="magicparlabel-41"> Familiarization of the main concepts in machine learning; softening the learning curve.</dd>
<dt class="description_label">Resources:</dt>
<dd class="description_item" id="magicparlabel-42"> On my GitHub page you can download the whole guide as a PDF or find the links to all parts of this series.
<dl class="description">
<dt class="description_label">PDF:</dt>
<dd class="description_item" id="magicparlabel-43"> <a href="https://github.com/ynaghibi/BlogsResources/blob/main/Machine_Learning_Blog.pdf">https://github.com/ynaghibi/BlogsResources/blob/main/Machine_Learning_Blog.pdf</a></dd>
<dt class="description_label">All Parts:</dt>
<dd class="description_item" id="magicparlabel-44"> <a href="https://github.com/ynaghibi/BlogsResources/blob/main/ML%20Guide%20Links">https://github.com/ynaghibi/BlogsResources/blob/main/ML%20Guide%20Links</a></dd>
<dt class="description_label">Python Script (Main):</dt>
<dd class="description_item" id="magicparlabel-45"> <a href="https://github.com/ynaghibi/BlogsResources/blob/main/KagglC1%20-%20SmallProject.py">KagglC1 - SmallProject.py</a> (save this in the same folder as the csv files from Kaggle before you run it)</dd>
<dt class="description_label">Kaggle:</dt>
<dd class="description_item" id="magicparlabel-46"> <a href="https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/submissions">House Prices - Advanced Regression Techniques</a></dd>
</dl>
</dd><dt class="description_label">Last Edit:</dt>
<dd class="description_item" id="magicparlabel-47"> 2025 April 03</dd>
<dt class="description_label">Credits:</dt>
<dd class="description_item" id="magicparlabel-48"> This guide is inspired by chapter 2 in "<i>Hands on Machine Learning</i>" by Aurélien Geron [<a href="#LyXCite-HoML"><span class="bib-label">HoML</span></a>]. I am in no way associated with the author himself. This guide does not replicate any parts of the book, and the code presented here is based on publicly available source codes (see Colab). </dd>
<dd class="description_item" id="magicparlabel-49"></dd>
</dl>
</section>
<section>
<h2 class="section" id="magicparlabel-54"><span class="section_label">2</span> How to read this guide</h2>
<div class="standard" id="magicparlabel-55">The source codes labeled as "<b>Jupyter Cell</b>" can be pasted in one python file in order to create a new Jupyter cell each time. The code labeled as "<b>Test</b>" is rather meant to deepen the understanding of the main code, but it is not required for any subsequent cell. There is also some code labeled as "<b>Output</b>", which just shows you the result of one of those cells.</div>
</section>
<section>
<h2 class="section" id="magicparlabel-56"><span class="section_label">3</span> Machine Learning with Python</h2>
<div class="standard" id="magicparlabel-57">In this guide we will start with some basics, then look at a small project example in order to get quickly familiarized with important concepts. and finally we will look at a bigger project example to show you further crucial steps in more detail.</div>
<div class="standard" id="magicparlabel-58">The procedure in both projects is basically the same. First the dataset is transformed in a way that improves the quality of the <b>prediction model</b>. This is done by sending the dataset through a so called <b>pipeline</b>. Then the model is trained with known targets, before it can predict unknown targets from another dataset (supervised learning). </div>
<section>
<h3 class="subsection" id="magicparlabel-63"><span class="subsection_label">3.1</span> First Steps</h3>
<div class="standard" id="magicparlabel-64">Usually each Jupyter cell generates at most one output in the interactive window, but it can be very practical to have multiple outputs per cell. This can be achieved with the <b><span style="font-size:x-small;">display</span></b> function. Next we need to import the modules <b><span style="font-size:x-small;">numpy</span></b>, <b><span style="font-size:x-small;">pandas</span></b> and <b><span style="font-size:x-small;">matplotlib.pyplot</span></b> (usually abbreviated as <b><span style="font-size:x-small;">np</span></b>, <b><span style="font-size:x-small;">pd</span></b> and <b><span style="font-size:x-small;">plt</span></b>) that will help us to explore the data. While <b><span style="font-size:x-small;">pyplot</span></b> is used for visualizing data, the <b><span style="font-size:x-small;">numpy</span></b> and <b><span style="font-size:x-small;">pandas</span></b> modules provide us with three types of extensively used data containers. Before we dive deeper into the machine learning aspect of this guide, we should get familiar with the containers.</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-68">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-73"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-74"><span style="font-size:x-small;">from IPython.display import <b><span style="font-family:sans-serif;">display</span></b></span></div>
<div class="lyx_code_item" id="magicparlabel-75"><span style="font-size:x-small;">display("Hello world!")</span></div>
<div class="lyx_code_item" id="magicparlabel-76"><span style="font-size:x-small;">display("second message")</span></div>
</div>
<div class="plain_layout" id="magicparlabel-77"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 1:  Jupyter Cell<a id="alg__first_step_display"></a></span></div>
</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-85">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-90"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-91"><span style="font-size:x-small;">import <b><span style="font-family:sans-serif;">numpy</span></b><span style="font-family:monospace;"> as np</span></span></div>
<div class="lyx_code_item" id="magicparlabel-92"><span style="font-size:x-small;">import <b><span style="font-family:sans-serif;">pandas</span></b><span style="font-family:monospace;"> as pd</span></span></div>
<div class="lyx_code_item" id="magicparlabel-93"><span style="font-size:x-small;">import <b><span style="font-family:sans-serif;">matplotlib</span></b><span style="font-family:monospace;">.pyplot as plt</span></span></div>
</div>
<div class="plain_layout" id="magicparlabel-94"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 2:  Jupyter Cell<a id="alg__first_step_modules"></a></span></div>
</div>
<section>
<h4 class="subsubsection" id="magicparlabel-99"><span class="subsubsection_label">3.1.1</span> Numpy and Pandas Containers</h4>
<dl class="description">
<dt class="description_label">Numpy Arrays</dt>
<dd class="description_item" id="magicparlabel-100"> or ndarray typed variables are often used for numerical computations due to their better performance speed. The data is stored in n-dimensional arrays. E.g. a 1D array has the shape of a vector, a 2D array the shape of a matrix, etc. The type of data stored in any given ndarray must always be the same, but other than that the data can have any valid type.</dd>
<dt class="description_label">Pandas DataFrames</dt>
<dd class="description_item" id="magicparlabel-101"> are always 2 dimensional arrays, but in addition their rows and columns have a label as well. In this sense they are very similar to spreadsheets or SQL tables. Usually column lables describe the <b>features </b>of the data, while the row labels describe each <b>sample</b> or instance (usually an index). For this purpose dataframes can store data with different types, even when they are stored in the same dataframe variable. </dd>
<dt class="description_label">Pandas Series</dt>
<dd class="description_item" id="magicparlabel-102"> are the 1 dimensional version of dataframes. This means their row has a label, and they can contain mixed data types as well. Whenever we extract a single column from a dataframe, we can obtain a pandas series. </dd>
</dl>
<div class="standard" id="magicparlabel-103">For beginners it can be helpful to print the type of these containers, because sometimes it can be hard to distinguish them. </div>
<div class="standard" id="magicparlabel-104">In order to get familiar with these types, it can be helpful to construct simple containers manually. </div>
<section>
<h5 class="paragraph" id="magicparlabel-105"><span class="paragraph_label"></span> Numpy ndarrays </h5>
<div class="standard" id="magicparlabel-106">First we want to create a numpy.ndarray with 3 rows and 5 columns with the number 1.2 in each entry. Then we want another ndarray containing 2 matrices with each having 4 columns, 3 rows, where the entries are defined by a custom function. Here we defined the dimensions of the ndarrays in n-tuples, which refers to the <b>shape</b> of an array. If you read these shapes from right to left, they give you the number of the columns, rows, etc. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-110">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-115"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-116"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">myarray</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> = np.full((3,5), 1.2)</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-117"><span style="font-size:x-small;">display(myarray)</span></div>
<div class="lyx_code_item" id="magicparlabel-118"><span style="font-size:x-small;">def myfunc(z, y, x):</span></div>
<div class="lyx_code_item" id="magicparlabel-119"><span style="font-size:x-small;">    return x*100 + y*10 + z</span></div>
<div class="lyx_code_item" id="magicparlabel-120"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">myfuncarray</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> = np.fromfunction(myfunc, (2,3,4)) </span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-121"><span style="font-size:x-small;">display(myfuncarray)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-122"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 3:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-127">An important programming concept is that we can operate along dimensional directions in arrays. Each dimensional direction is called an <b>axis</b>. E.g. moving along the direction of columns gives us the <math xmlns="http://www.w3.org/1998/Math/MathML">
<mn>0</mn>
</math>
th axis, rows give use the <math xmlns="http://www.w3.org/1998/Math/MathML">
<mn>1</mn>
</math>
st axis, etc. This makes more sense, once we look at the output of the previous code. You can see a bunch of nested arrays inside brackets. The arrays in the inner most brackets have the same lengths as the number of columns. More precisely, the <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>i</mi>
</math>
-th inner array has the entries of the <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>i</mi>
</math>
-th matrix-row, which has the form row_i = [e_1, ..., e_n] with <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>n</mi>
</math>
 being the number of columns (along <b>axis 0</b>). </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-131">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-136"><span style="font-size:x-small;">array([[1.2, 1.2, 1.2, 1.2, 1.2],</span></div>
<div class="lyx_code_item" id="magicparlabel-137"><span style="font-size:x-small;">       [1.2, 1.2, 1.2, 1.2, 1.2],</span></div>
<div class="lyx_code_item" id="magicparlabel-138"><span style="font-size:x-small;">       [1.2, 1.2, 1.2, 1.2, 1.2]])</span></div>
<div class="lyx_code_item" id="magicparlabel-139"> </div>
<div class="lyx_code_item" id="magicparlabel-140"><span style="font-size:x-small;">array([[[  0., 100., 200., 300.],</span></div>
<div class="lyx_code_item" id="magicparlabel-141"><span style="font-size:x-small;">        [ 10., 110., 210., 310.],</span></div>
<div class="lyx_code_item" id="magicparlabel-142"><span style="font-size:x-small;">        [ 20., 120., 220., 320.]],</span></div>
<div class="lyx_code_item" id="magicparlabel-143"> </div>
<div class="lyx_code_item" id="magicparlabel-144"><span style="font-size:x-small;">       [[  1., 101., 201., 301.],</span></div>
<div class="lyx_code_item" id="magicparlabel-145"><span style="font-size:x-small;">        [ 11., 111., 211., 311.],</span></div>
<div class="lyx_code_item" id="magicparlabel-146"><span style="font-size:x-small;">        [ 21., 121., 221., 321.]]])</span></div>
</div>
<div class="plain_layout" id="magicparlabel-147"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 4:  Output</span></div>
</div>
<div class="standard" id="magicparlabel-152">On the next level we have a matrix of the form [row_1, ..., row_m], where <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>m</mi>
</math>
 is the number of rows (<b>axis 1</b>). Then we could have an array of matrices of the form [matrix_1, matrix_2, ...] (<b>axis 2</b>). This pattern continues until we reached the last axis of the array. </div>
<div class="standard" id="magicparlabel-153">E.g. the first array in the previous output has axis 0 length = 5 and axis 1 length = 3, while the scond array has axis 0 length = 4, axis 1 length = 3 and axis 2 length = 2. </div>
<div class="standard" id="magicparlabel-154">The axis length should not be confused with the <b>array dimension</b> (or <b>rank</b>), which equals the total amount of axes. (As we will see later, only 2 dimensional arrays can be used for "pipelines".) In our example <b><span style="font-size:x-small;">myfuncarray</span></b> is a 3D and <b><span style="font-size:x-small;">myarray</span></b> a 2D array.</div>
<div class="standard" id="magicparlabel-155">Another important value is the <b>size</b> of an array defined as the product of all axis lengths in the array shape (e.g. <b><span style="font-size:x-small;">myfuncarray</span></b> has the size <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<mn>4</mn>
<mo>⋅</mo>
<mn>3</mn>
<mo>⋅</mo>
<mn>2</mn>
<mo stretchy="false">=</mo>
<mn>12</mn>
</mrow>
</math>
). Obviously, each time we want to reshape an array in order to rearrange its entries, the array size must be the same.</div>
<div class="standard" id="magicparlabel-156">Of course viewing arrays like in the previous output can become hard to read at some point, but in most cases we do not have to look at the entirety of the entries. For instance we can get a single entry like <b><span style="font-size:x-small;">myfuncarray[1,0,3]</span></b>. Since the indices start counting at 0, this would give you the entry of the first row in the fourth column from the second matrix in <b><span style="font-size:x-small;">myfuncarray</span></b>, which is 301.0 in this case.</div>
<div class="standard" id="magicparlabel-157">With Python’s <b>slice indices</b> we can also replace each single index with a whole range of them. The syntax requires colons like in <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>i</mi>
<mstyle mathvariant="normal">
<mrow>
<mi>S</mi>
<mi>t</mi>
<mi>a</mi>
<mi>r</mi>
<mi>t</mi>
</mrow>
</mstyle>
</msub>
</math>
 : <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>i</mi>
<mstyle mathvariant="normal">
<mrow>
<mi>E</mi>
<mi>n</mi>
<mi>d</mi>
</mrow>
</mstyle>
</msub>
</math>
, where the indices start at <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>i</mi>
<mstyle mathvariant="normal">
<mrow>
<mi>S</mi>
<mi>t</mi>
<mi>a</mi>
<mi>r</mi>
<mi>t</mi>
</mrow>
</mstyle>
</msub>
</math>
 and end at <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msub>
<mi>i</mi>
<mstyle mathvariant="normal">
<mrow>
<mi>E</mi>
<mi>n</mi>
<mi>d</mi>
</mrow>
</mstyle>
</msub>
<mo stretchy="false">-</mo>
<mn>1</mn>
</mrow>
</math>
. It is also possible to omit <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>i</mi>
<mstyle mathvariant="normal">
<mrow>
<mi>S</mi>
<mi>t</mi>
<mi>a</mi>
<mi>r</mi>
<mi>t</mi>
</mrow>
</mstyle>
</msub>
</math>
, in which case the indices will start at 0. Similarly, we can omit <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>i</mi>
<mstyle mathvariant="normal">
<mrow>
<mi>E</mi>
<mi>n</mi>
<mi>d</mi>
</mrow>
</mstyle>
</msub>
</math>
 in order reach the last available index. E.g. if we only wanted the second and third columns of the very first matrix in <b><span style="font-size:x-small;">myfuncarray</span></b>, then we would write The output shows us that, while the shape of the original 3D array <b><span style="font-size:x-small;">myfuncarray</span></b> is (2, 3, 4), the new array <b><span style="font-size:x-small;">simplematr</span></b> has the shape (3, 2) and a dimension of 2. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-161">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-166"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-167"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">simplematr</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> = myfuncarray[0, :, 1:3]</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-168"><span style="font-size:x-small;">display(simplematr)</span></div>
<div class="lyx_code_item" id="magicparlabel-169"><span style="font-size:x-small;">display(myfuncarray.shape)</span></div>
<div class="lyx_code_item" id="magicparlabel-170"><span style="font-size:x-small;">display(simplematr.shape)</span></div>
<div class="lyx_code_item" id="magicparlabel-171"><span style="font-size:x-small;">display(simplematr.ndim)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-172"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 5:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-177">Note that changing the contents of an array slice also changes the contents of the original array accordingly. E.g. gives us the output <b><span style="font-size:x-small;">999</span></b>. If you do not want this kind of behavior, you can copy the content with the <b><span style="font-size:x-small;">.copy()</span></b> method. E.g.  passes the array "by value" instead of passing it "by reference". In general we say in the first case that the variable is returned as a <b>view</b> and in the second case as a <b>copy</b>. As a result the output of this code is <b><span style="font-size:x-small;">221</span></b> instead of <b><span style="font-size:x-small;">999</span></b>. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-181">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-186"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-187"><span style="font-size:x-small;">simplematr[2,1] = 999</span></div>
<div class="lyx_code_item" id="magicparlabel-188"><span style="font-size:x-small;">display(myfuncarray[0,2,2]) </span></div>
</div>
<div class="plain_layout" id="magicparlabel-189"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 6:  Test</span></div>
</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-197">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-202"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-203"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">simplematr2</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> = myfuncarray[1, :, 1:3].</span><b><span style="font-family:sans-serif;">copy</span></b><span style="font-family:monospace;">()</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-204"><span style="font-size:x-small;">simplematr2[2,1] = 999</span></div>
<div class="lyx_code_item" id="magicparlabel-205"><span style="font-size:x-small;">display(myfuncarray[1,2,2]) </span></div>
</div>
<div class="plain_layout" id="magicparlabel-206"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 7:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-211">In some cases it is important to leave the dimension of an array untouched (e.g. for "pipelines"). This can be done either by using the colons syntax in each index component, or we can write single indices in double brackets. The following code shows both approaches. Here we want the second matrix of <b><span style="font-size:x-small;">myfuncarray</span></b> in form of a 3D array instead of 2D.You can check that both <b><span style="font-size:x-small;">newmatr_1</span></b> and <b><span style="font-size:x-small;">newmatr_2</span></b> have the shape (1, 3, 4). This means that these arrays have only one element along their axis 2, which is the matrix we wanted. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-215">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-220"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-221"><span style="font-size:x-small;">newmatr_1 =  myfuncarray[1:2,:,:]</span></div>
<div class="lyx_code_item" id="magicparlabel-222"><span style="font-size:x-small;">newmatr_2 =  myfuncarray[[1],:,:]</span></div>
</div>
<div class="plain_layout" id="magicparlabel-223"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 8:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-228">At this point we have already learned a lot of important concepts. Still there are two main concepts left that are very versatile especially when combined together: <b>pointwise operations</b> and <b>broadcasting</b>. </div>
<div class="standard" id="magicparlabel-229">In general a pointwise operation is applied on each entry of the involved arrays. Therefore, binary operations (like "+", "*", "&lt;") can only be used for arrays with the same shape. Under certain conditions it is possible that arrays can be reshaped automatically in a way that these operations become possible (broadcasting). </div>
<div class="standard" id="magicparlabel-230">Before we explain the rules of broadcasting in general, we want to look at a simple example, where we introduce two 1 dimensional arrays with the size 7. Note that in this case the shape is not written as (7) but rather as (7, ). Here we kept the code short by making use of lambda functions, and with <b><span style="font-size:x-small;">dtype</span></b> we can replace the default float number outputs with easier to read integers. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-234">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-239"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-240"><span style="font-size:x-small;">arr_1 = np.fromfunction(<b><span style="font-family:sans-serif;">lambda</span></b><span style="font-family:monospace;"> x: x, </span><b><span style="font-family:sans-serif;">(7,)</span></b><span style="font-family:monospace;">, </span><b><span style="font-family:sans-serif;">dtype</span></b><span style="font-family:monospace;"> = np.int32)</span></span></div>
<div class="lyx_code_item" id="magicparlabel-241"><span style="font-size:x-small;">arr_2 = np.fromfunction(lambda x: 2*x, (7,), dtype = np.int32)</span></div>
<div class="lyx_code_item" id="magicparlabel-242"><span style="font-size:x-small;">display(arr_1)</span></div>
<div class="lyx_code_item" id="magicparlabel-243"><span style="font-size:x-small;">display(arr_2)</span></div>
<div class="lyx_code_item" id="magicparlabel-244"><span style="font-size:x-small;">display(arr_1 <b><span style="font-family:sans-serif;">+</span></b><span style="font-family:monospace;"> arr_2)</span></span></div>
<div class="lyx_code_item" id="magicparlabel-245"><span style="font-size:x-small;">display(arr_2 <b><span style="font-family:sans-serif;">&lt;</span></b><span style="font-family:monospace;"> 5)</span></span></div>
<div class="lyx_code_item" id="magicparlabel-246"><span style="font-size:x-small;">display(arr_2[arr_2 <b><span style="font-family:sans-serif;">&lt;</span></b><span style="font-family:monospace;"> 5])</span></span></div>
</div>
<div class="plain_layout" id="magicparlabel-247"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 9:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-252">Thanks to the broadcasting rules it is possible to apply binary operations on an array and a number like in <b><span style="font-size:x-small;">arr_2 &lt; 5</span></b>: By simply repeating the number 5 along all axes of <b><span style="font-size:x-small;">arr_2</span></b>, we get matching shapes. Note that numbers can be considered as special types of arrays with the shape (1,). The last line in the output demonstrates a very hepful technique, where a 1D array with boolean values is used to select rows from another 1D array with the same size. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-256">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-261"><span style="font-size:x-small;">array([0, 1, 2, 3, 4, 5, 6])</span></div>
<div class="lyx_code_item" id="magicparlabel-262"><span style="font-size:x-small;">array([ 0,  2,  4,  6,  8, 10, 12])</span></div>
<div class="lyx_code_item" id="magicparlabel-263"><span style="font-size:x-small;">array([ 0,  3,  6,  9, 12, 15, 18])</span></div>
<div class="lyx_code_item" id="magicparlabel-264"><span style="font-size:x-small;">array([ True,  True,  True, False, False, False, False])</span></div>
<div class="lyx_code_item" id="magicparlabel-265"><span style="font-size:x-small;">array([0, 2, 4])</span></div>
</div>
<div class="plain_layout" id="magicparlabel-266"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 10:  Output</span></div>
</div>
<div class="standard" id="magicparlabel-271">For now it should be enough to understand the broadcasting rule for numbers, but you should be already able to understand the rules in general, if you want:</div>
<ol class="lyxenum enumi">
<li class="enumerate_item" id="magicparlabel-272">If two arrays of the same dimension <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>k</mi>
</math>
 have the shape (<math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>n</mi>
<mn>0</mn>
</msub>
</math>
, <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>…</mi>
</math>
, <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>n</mi>
<mrow>
<mi>k</mi>
<mo stretchy="false">-</mo>
<mn>1</mn>
</mrow>
</msub>
</math>
) and (<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msub>
<mi>m</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">,</mo>
</mrow>
</math>
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>…</mi>
</math>
, <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>m</mi>
<mrow>
<mi>k</mi>
<mo stretchy="false">-</mo>
<mn>1</mn>
</mrow>
</msub>
</math>
), respectively, and if <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
<mo>≠</mo>
<msub>
<mi>m</mi>
<mi>i</mi>
</msub>
</mrow>
</math>
 always implies that <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">=</mo>
<mn>1</mn>
</mrow>
</math>
 or <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msub>
<mi>m</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">=</mo>
<mn>1</mn>
</mrow>
</math>
, then both arrays can be matched. E.g if <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">=</mo>
<mn>1</mn>
</mrow>
</math>
, then there is only one element along the axis <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>i</mi>
</math>
. This element can then be repeated <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>m</mi>
<mi>i</mi>
</msub>
</math>
 times along the axis <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>i</mi>
</math>
 until the axis lengths of both arrays match. </li>
<li class="enumerate_item" id="magicparlabel-273">If two arrays do not have the same dimension, then the dimension of the smaller array is matched by appending axis lengths of "1" to the left of the shape-tupel. E.g. arrays with the shape (7, 5, 3) and (3, ) are matched by changing the shape of the second array to (1, 1, 3), and then repeating the entries in the first and second axes until the second array has the shape (7, 5, 3) as well.</li>
</ol>
<div class="standard" id="magicparlabel-274">Of course these broadcasting rules do not apply in other circumstances, when there is an axis <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>i</mi>
</math>
 such that <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
<mo>≠</mo>
<msub>
<mi>m</mi>
<mi>i</mi>
</msub>
</mrow>
</math>
 and <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
<mo>≠</mo>
<mn>1</mn>
<mo>≠</mo>
<msub>
<mi>m</mi>
<mi>i</mi>
</msub>
</mrow>
</math>
. </div>
</section>
<section>
<h5 class="paragraph" id="magicparlabel-284"><span class="paragraph_label"></span> Pandas dataframes and series</h5>
<div class="standard" id="magicparlabel-285">Some of our knowledge about numpy ndarrays can be applied to pandas series and dataframes as well. Before diving in, we want to define a dataframe <b><span style="font-size:x-small;">df_customer_raw</span></b> storing the data of customer transactions. Each transaction has features like the product type (in form of strings), the price (floats) and the amount of products sold (integers). If we define dataframes like this, their column and row labels will be automatically generated indices. More useful labels can be added, if we initialize dataframe with the arguments <b><span style="font-size:x-small;">index</span></b> and <b><span style="font-size:x-small;">columns</span></b>. In our example the rows have customer names and the columns feature names. The following code also shows how we can get the numpy ndarray version of a dataframe by using <b><span style="font-size:x-small;">.values</span></b>.The output<span style="font-size:x-small;"> </span>shows that the datatype of the ndarray is <b><span style="font-size:x-small;">object</span></b>. This type already contains mixed types like strings or floats. Otherwise it would not be possible to mix different types in a ndarray. (Note that <b><span style="font-size:x-small;">object</span></b> types can decrease the computational time compared to pure numerical types.)</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-289">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-294"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-295"><span style="font-size:x-small;">customer_list = [</span></div>
<div class="lyx_code_item" id="magicparlabel-296"><span style="font-size:x-small;">    ["Laptop", 1199.99, 10],</span></div>
<div class="lyx_code_item" id="magicparlabel-297"><span style="font-size:x-small;">    ["Phone", 812.35, 50],</span></div>
<div class="lyx_code_item" id="magicparlabel-298"><span style="font-size:x-small;">    ["Tablet", 300.0, 1],</span></div>
<div class="lyx_code_item" id="magicparlabel-299"><span style="font-size:x-small;">    ["Monitor", 511.5, 35],</span></div>
<div class="lyx_code_item" id="magicparlabel-300"><span style="font-size:x-small;">]</span></div>
<div class="lyx_code_item" id="magicparlabel-301"><span style="font-size:x-small;">df_customer_raw = <b><span style="font-family:sans-serif;">pd.DataFrame</span></b><span style="font-family:monospace;">(data = customer_list)</span></span></div>
<div class="lyx_code_item" id="magicparlabel-302"><span style="font-size:x-small;">display(df_customer_raw)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-303"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 11:  Test</span></div>
</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-311">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-316"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-317"><span style="font-size:x-small;">df_customer = pd.DataFrame(</span></div>
<div class="lyx_code_item" id="magicparlabel-318"><span style="font-size:x-small;">    data = customer_list,</span></div>
<div class="lyx_code_item" id="magicparlabel-319"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">index</span></b><span style="font-family:monospace;"> = ["Alice", "Charles", "Bob", "Dan"],</span></span></div>
<div class="lyx_code_item" id="magicparlabel-320"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">columns</span></b><span style="font-family:monospace;"> = ["Product", "Price", "Sold"]</span></span></div>
<div class="lyx_code_item" id="magicparlabel-321"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-322"><span style="font-size:x-small;">display(df_customer)</span></div>
<div class="lyx_code_item" id="magicparlabel-323"><span style="font-size:x-small;">display(df_customer<b><span style="font-family:sans-serif;">.values</span></b><span style="font-family:monospace;">)</span></span></div>
</div>
<div class="plain_layout" id="magicparlabel-324"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 12:  Test</span></div>
</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-332">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-337"><span style="font-size:x-small;">       <b><span style="font-family:sans-serif;">Product	Price	Sold</span></b></span></div>
<div class="lyx_code_item" id="magicparlabel-338"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">Alice</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> 	Laptop	1199.99	10</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-339"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">Charles</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> 	Phone	812.35	50</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-340"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">Bob</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> 	Tablet	300.00	1</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-341"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">Dan</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> 	Monitor	511.50	35</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-342"> </div>
<div class="lyx_code_item" id="magicparlabel-343"><span style="font-size:x-small;">array([[’Laptop’, 1199.99, 10],</span></div>
<div class="lyx_code_item" id="magicparlabel-344"><span style="font-size:x-small;">       [’Phone’, 812.35, 50],</span></div>
<div class="lyx_code_item" id="magicparlabel-345"><span style="font-size:x-small;">       [’Tablet’, 300.0, 1],</span></div>
<div class="lyx_code_item" id="magicparlabel-346"><span style="font-size:x-small;">       [’Monitor’, 511.5, 35]], dtype=<b><span style="font-family:sans-serif;">object</span></b><span style="font-family:monospace;">)</span></span></div>
</div>
<div class="plain_layout" id="magicparlabel-347"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 13:  Output</span></div>
</div>
<div class="standard" id="magicparlabel-352">If we want to access specific columns or rows from dataframes, they will be converted to 1D pandas series. Here <b><span style="font-size:x-small;">.loc</span></b> gives us the row for the specified label <b><span style="font-size:x-small;">"Bob"</span></b>. If we ommitted <b><span style="font-size:x-small;">.loc</span></b>, we would get a column with the label <b><span style="font-size:x-small;">"Bob"</span></b>, which does not exist in our dataframe. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-356">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-361"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-362"><span style="font-size:x-small;">display( df_customer["Product"] ) #column</span></div>
<div class="lyx_code_item" id="magicparlabel-363"><span style="font-size:x-small;">display( df_customer.<b><span style="font-family:sans-serif;">loc</span></b><span style="font-family:monospace;">["Bob"] ) #row</span></span></div>
<div class="lyx_code_item" id="magicparlabel-364"><span style="font-size:x-small;">display( df_customer.<b><span style="font-family:sans-serif;">loc</span></b><span style="font-family:monospace;">["Bob", "Product"] ) #data </span></span></div>
</div>
<div class="plain_layout" id="magicparlabel-365"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 14:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-370">In the last line we could have also used the more intuitive syntax <b><span style="font-size:x-small;">df_customer["Product"]["Bob"]</span></b> instead, if we only wanted to read the data. However, if we intend to write the data, it is not guaranteed whether the data is returned as a copy or a view (it depends on internal implementations).</div>
<div class="standard" id="magicparlabel-371">In addition, using <b><span style="font-size:x-small;">.loc</span></b> makes our intention clear, whether we want to refer to so called <b>label positions</b> or <b>ordinal positions</b>. E.g. <b><span style="font-size:x-small;">"Bob"</span></b> is a label position, but its ordinal position in our <b><span style="font-size:x-small;">index</span></b> list is 2 (while e.g. <b><span style="font-size:x-small;">"Alice"</span></b> has the position 0). Therefore an alternative way to access Bob’s customer data is because <b><span style="font-size:x-small;">.iloc</span></b> always accesses ordinal positions. One of the advantages of ordinal positions is that we can use slicing in combination with <b><span style="font-size:x-small;">.iloc</span></b>. Just like for numpy ndarrays the slicing method preserves the dimension of the 2D dataframe instead of transforming it into a 1D series. E.g. <b><span style="font-size:x-small;">df_customer.iloc[0:2]</span></b> gives us the first two customers in form of a new dataframe. Of course slicing also works for series. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-375">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-380"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-381"><span style="font-size:x-small;">df_customer.<b><span style="font-family:sans-serif;">iloc</span></b><span style="font-family:monospace;">[2]</span></span></div>
</div>
<div class="plain_layout" id="magicparlabel-382"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 15:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-387">The general rule of thumb is to use <b><span style="font-size:x-small;">.iloc</span></b> for ordinal and <b><span style="font-size:x-small;">.loc</span></b> for label positions. Otherwise it can create confusing situations, where integer numbers are used as labels, while these labels do not represent the real ordinal positions. </div>
<div class="standard" id="magicparlabel-388">As you may have noticed in some of the outputs, each series extracted from dataframes has a name equal to the label of the corresponding column or row. Conversely, we can add a series as a new column in dataframes. So let us add the birthyear for each customer with It is a very intuitive and short way to create new columns like this, but if assume that <b><span style="font-size:x-small;">df_customer</span></b> was a slice of a bigger dataframe, then this syntax would not guarantee whether the original dataframe would also change after creating the new column. In those cases it is recommended to use the <b><span style="font-size:x-small;">.assign</span></b> method, which requires a lengthier syntax like <b><span style="font-size:x-small;">df_customer = df_customer.assign(Birthyear = birthcol)</span></b>. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-392">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-397"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-398"><span style="font-size:x-small;">birthcol = pd.Series(</span></div>
<div class="lyx_code_item" id="magicparlabel-399"><span style="font-size:x-small;">    data = [1990, 2000, 1980, 2010],</span></div>
<div class="lyx_code_item" id="magicparlabel-400"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">name</span></b><span style="font-family:monospace;"> = "Birthyear",</span></span></div>
<div class="lyx_code_item" id="magicparlabel-401"><span style="font-size:x-small;">    index = df_customer.<b><span style="font-family:sans-serif;">index</span></b></span></div>
<div class="lyx_code_item" id="magicparlabel-402"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-403"><span style="font-size:x-small;">df_customer[birthcol.name] = birthcol</span></div>
<div class="lyx_code_item" id="magicparlabel-404"><span style="font-size:x-small;">display(df_customer)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-405"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 16:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-410">For starters it is already sufficient to apply <b><span style="font-size:x-small;">.assign</span></b>. for this reason only. However, another situation where <b><span style="font-size:x-small;">.assign</span></b> is useful is for so called <b>chaining</b> methods, when we want to execute several operations in one expression without the need for intermediate variables. </div>
<div class="standard" id="magicparlabel-411">This means we can create multiple new columns in a single <b><span style="font-size:x-small;">.assign</span></b> chain, even if some columns depend on others initialized earlier in the chain. We only have to make sure that <b><span style="font-size:x-small;">.assign</span></b> does not try to initialize all columns simultaneously. This is why we have to wrap the initializations in lambdas or functions, which "delay" these operations until they are called sequentially in the chain: Note that with this method changing any data inside <b><span style="font-size:x-small;">df_new</span></b> does not change <b><span style="font-size:x-small;">df_customer</span></b> at all. You also do not have to fear causing too much overhead thanks to "Copy-on-Write", where the memory of the new and the original dataframes share the same memory until they are changed.</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-415">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-420"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-421"><span style="font-size:x-small;">df_new = (df_customer</span></div>
<div class="lyx_code_item" id="magicparlabel-422"><span style="font-size:x-small;">    .<b><span style="font-family:sans-serif;">assign</span></b><span style="font-family:monospace;">(Revenue = lambda df: df["Price"] * df["Sold"])</span></span></div>
<div class="lyx_code_item" id="magicparlabel-423"><span style="font-size:x-small;">    .<b><span style="font-family:sans-serif;">assign</span></b><span style="font-family:monospace;">(HighProfit = lambda df: df["Revenue"] &gt; 11000)</span></span></div>
<div class="lyx_code_item" id="magicparlabel-424"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-425"><span style="font-size:x-small;">display(df_customer)</span></div>
<div class="lyx_code_item" id="magicparlabel-426"><span style="font-size:x-small;">display(df_new)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-427"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 17:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-432">Last but not least, we can remove existing columns or rows with <b><span style="font-size:x-small;">.drop</span></b>.A more traditional way of dropping columns or rows is to use axes arguments, i.e. we could have also used <b><span style="font-size:x-small;">df_customer.drop("Bob", axis = 0)</span></b> for dropping a row.</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-436">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-441"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-442"><span style="font-size:x-small;">df_customer = df_customer.<b><span style="font-family:sans-serif;">drop</span></b><span style="font-family:monospace;">(columns=["Sold",  "Price"])</span></span></div>
<div class="lyx_code_item" id="magicparlabel-443"><span style="font-size:x-small;">df_customer = df_customer.<b><span style="font-family:sans-serif;">drop</span></b><span style="font-family:monospace;">(index=["Bob"])</span></span></div>
<div class="lyx_code_item" id="magicparlabel-444"><span style="font-size:x-small;">display(df_customer)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-445"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 18:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-450">Now that you are familiar enough with numpy/pandas data container, you should have a solid knowledge to move on. However, if you want to deepen your knowledge at some point, I can recommend Aurélien Géron’s online tutorial on Colab [<a href="#LyXCite-Geron_Colab"><span class="bib-label">GeronColab</span></a>]. Or you can try out books like [<a href="#LyXCite-VanderPlas"><span class="bib-label">VanderPlas</span></a>].</div>
</section>
</section>
<section>
<h4 class="subsubsection" id="magicparlabel-451"><span class="subsubsection_label">3.1.2</span> Getting the data</h4>
<div class="standard" id="magicparlabel-452">Before analyzing the data, we have to load them into the system. There are multiple ways to do this. For instance we can automatically download and extract the data, or even use SQL directly in Jupyter cells in order to handle large datasets efficiently. </div>
<div class="standard" id="magicparlabel-453">For now we want to keep it simple. Download and extract the <b>train.csv</b> and <b>test.csv</b> files manually from the Kaggle competition site, and save them in the same folder as your Python script. Here we have stored the data as <b><span style="font-size:x-small;">housing</span></b> and <b><span style="font-size:x-small;">housing_unknown</span></b> dataframe variables. After running this cell you will see the table structure of <b><span style="font-size:x-small;">housing</span></b> and <b><span style="font-size:x-small;">housing_unknown</span></b>. The output should show you a few example rows for both dataframes. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-457">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-462"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-463"><span style="font-size:x-small;">from pathlib import Path</span></div>
<div class="lyx_code_item" id="magicparlabel-464"><span style="font-size:x-small;">sLocal_Folder_Path = Path(__file__).parent.resolve()</span></div>
<div class="lyx_code_item" id="magicparlabel-465"><span style="font-size:x-small;">train_file_path = sLocal_Folder_Path / "train.csv" # Uses OS-appropriate separator</span></div>
<div class="lyx_code_item" id="magicparlabel-466"><span style="font-size:x-small;">predict_file_path = sLocal_Folder_Path / "test.csv"</span></div>
<div class="lyx_code_item" id="magicparlabel-467"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">housing</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> = pd.read_csv(train_file_path)</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-468"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">housing_unknown</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> = pd.read_csv(predict_file_path)</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-469"><span style="font-size:x-small;">display(housing)</span></div>
<div class="lyx_code_item" id="magicparlabel-470"><span style="font-size:x-small;">display(housing_unknown)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-471"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 19:  Jupyter Cell</span></div>
</div>
<div class="standard" id="magicparlabel-476">It should also tell you that <b><span style="font-size:x-small;">housing</span></b> has 81 columns, while <b><span style="font-size:x-small;">housing_unknown</span></b> has only 80 columns. The missing column are the targets, which are the house sales prices we will have to predict before submitting it on Kaggle. The dataset from <b><span style="font-size:x-small;">housing</span></b> on the other hand will be used to train and test our prediction models before our final submission.</div>
</section>
</section>
<section>
<h3 class="subsection" id="magicparlabel-477"><span class="subsection_label">3.2</span> Small Project</h3>
<div class="standard" id="magicparlabel-478">Make sure you add the Jupyter cells from the previous <b>"First Steps"</b> section (algorithms <a href="#alg__first_step_display">1</a> and <a href="#alg__first_step_modules">2</a>). </div>
<div class="standard" id="magicparlabel-479">In our case one <b>sample</b> is the data of a single house with <b>features</b> like the total number of bedrooms, while the target is simply the sale price. Before we can train a model we have to separate the target-column from the feature columns.</div>
<div class="standard" id="magicparlabel-480">In addition, we need to separate the so called <b>train set</b> from the <b>test set</b>. One way to achieve this is by using the function <b><span style="font-size:x-small;">train_test_split</span></b>. The test set will help us to measure the performance of our model. This is done by computing the predicted target <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<mi>h</mi>
<mrow>
<mo>(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>)</mo>
</mrow>
</mrow>
</math>
 based on the feature values of a sample <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</math>
, and comparing it with the known targets <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
</math>
. Then we can estimate the error with measures like the so called <b>root mean square error</b> (<b>RMSE</b>)
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<mstyle mathvariant="normal">
<mrow>
<mi>R</mi>
<mi>M</mi>
<mi>S</mi>
<mi>E</mi>
</mrow>
</mstyle>
<mo stretchy="false">=</mo>
<msqrt>
<mrow>
<mfrac>
<mn>1</mn>
<mi>n</mi>
</mfrac>
<munderover>
<mo>∑</mo>
<mrow>
<mi>i</mi>
<mo stretchy="false">=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</munderover>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">-</mo>
<mi>h</mi>
<mrow>
<mo>(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
</msqrt>
</mrow>
</math>
where <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>n</mi>
</math>
 is the number of samples. A smaller RMSE indicates that the prediction of our model is more precise.</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-484">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-489"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-490"><span style="font-size:x-small;">from sklearn.model_selection import train_test_split</span></div>
<div class="lyx_code_item" id="magicparlabel-491"><span style="font-size:x-small;">train_set, test_set = train_test_split(</span></div>
<div class="lyx_code_item" id="magicparlabel-492"><span style="font-size:x-small;">    housing, test_size = 0.05, random_state = 42</span></div>
<div class="lyx_code_item" id="magicparlabel-493"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-494"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">housing</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> = train_set.drop("SalePrice", axis=1)</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-495"><b><span style="font-family:sans-serif;"><span style="font-size:x-small;">housing_targets</span></span></b><span style="font-family:sans-serif;"><span style="font-size:x-small;"><!-- Output Error: Tried to close pending tag `span' when other tags were pending. Last pending tag is `<span style='font-size:x-small;'>'. Tag discarded. -->
<span style="font-family:monospace;"> = train_set["SalePrice"].copy()</span></span></span></div>
<div class="lyx_code_item" id="magicparlabel-496"> </div>
<div class="lyx_code_item" id="magicparlabel-497"><span style="font-size:x-small;">housing_final_test = test_set.drop("SalePrice", axis=1)</span></div>
<div class="lyx_code_item" id="magicparlabel-498"><span style="font-size:x-small;">housing_targets_final_test = test_set["SalePrice"].copy()</span></div>
</div>
<div class="plain_layout" id="magicparlabel-499"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 20:  Jupyter Cell</span></div>
</div>
<div class="standard" id="magicparlabel-504">Of course we could use the samples <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</math>
 and targets <math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
</math>
 from the training set, i.e. the old dataset on which our model was trained. The problem is that the model prediction may be much worse for samples that are not part of the training set. The reason is that models can "get used" so much to the training set that they do not generalize very well.</div>
<div class="standard" id="magicparlabel-505">This is called overfitting. It usually occurs, when the prediction model has too much freedom for finding highly specialized rules that can only predict the trained targets very well. </div>
<div class="standard" id="magicparlabel-506">Therefore it is more reliable to calculate an error measure on the test set instead of train set. In our case the test set has only about 0.05% (<b><span style="font-size:x-small;">test_size</span></b>) of the original samples. Usually you want a more reliable test set ratio, but in our case it would decrease the number of samples in the training set too much, if <b><span style="font-size:x-small;">test_size</span></b> was much larger.</div>
<div class="standard" id="magicparlabel-507">Next we want to choose one of the prediction models that is already available from the <b><span style="font-size:x-small;">sklearn</span></b>-module. For this simple example a linear regressor is fine. <b>Regressors</b> are used for predicting numerical targets like the house sale prices, otherwise we would need a <b>classifier</b> for predicting categorical targets (categorical targets are also called labels, which should not be confused with the column/row labels of dataframes). As you can see, we have also imported other modules that introduce new objects like <b>pipelines</b> and <b>transformers</b>. Before we continue with our project, we should take a look at a simple application of pipelines and transformers, where the values of the features <b><span style="font-size:x-small;">"OverallQual"</span></b><span style="font-size:x-small;"> </span>and<span style="font-size:x-small;"> <b>"GarageArea"</b></span> are incremented by +1 and then multiplied with the factor 2 after being transformed by the <b><span style="font-size:x-small;">example_pipe</span></b> pipeline. If e.g. an entry in <b><span style="font-size:x-small;">example_df</span></b> equals <math xmlns="http://www.w3.org/1998/Math/MathML">
<mn>3</mn>
</math>
, then the corresponding entry in <b><span style="font-size:x-small;">example_trafo</span></b> is <math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<mrow>
<mo>(</mo>
<mrow>
<mn>3</mn>
<mo stretchy="false">+</mo>
<mn>1</mn>
</mrow>
<mo>)</mo>
</mrow>
<mo>⋅</mo>
<mn>2</mn>
<mo stretchy="false">=</mo>
<mn>8</mn>
</mrow>
</math>
. Note that the double brackets in <b><span style="font-size:x-small;">housing[["OverallQual", "GarageArea"]]</span></b> result in a dataframe with two feature columns from the <b><span style="font-size:x-small;">housing</span></b> dataframe. If we used only single brackets, we would have obtained a 1D pandas.series, which cannot be used as an input for pipelines.</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-511">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-516"><span style="font-size:x-small;">#%%</span></div>
<div class="lyx_code_item" id="magicparlabel-517"><span style="font-size:x-small;">from sklearn.linear_model import LinearRegression</span></div>
<div class="lyx_code_item" id="magicparlabel-518"><span style="font-size:x-small;">from sklearn.pipeline import Pipeline</span></div>
<div class="lyx_code_item" id="magicparlabel-519"><span style="font-size:x-small;">from sklearn.pipeline import make_pipeline</span></div>
<div class="lyx_code_item" id="magicparlabel-520"><span style="font-size:x-small;">from sklearn.preprocessing import StandardScaler</span></div>
<div class="lyx_code_item" id="magicparlabel-521"><span style="font-size:x-small;">from sklearn.impute import SimpleImputer</span></div>
<div class="lyx_code_item" id="magicparlabel-522"><span style="font-size:x-small;">from sklearn.preprocessing import FunctionTransformer</span></div>
<div class="lyx_code_item" id="magicparlabel-523"><span style="font-size:x-small;">from sklearn.compose import TransformedTargetRegressor</span></div>
<div class="lyx_code_item" id="magicparlabel-524"><span style="font-size:x-small;">from sklearn.compose import ColumnTransformer</span></div>
</div>
<div class="plain_layout" id="magicparlabel-525"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 21:  Jupyter Cell</span></div>
</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-533">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-538"><span style="font-size:x-small;">#%% Test</span></div>
<div class="lyx_code_item" id="magicparlabel-539"><span style="font-size:x-small;">def increment_func(x):</span></div>
<div class="lyx_code_item" id="magicparlabel-540"><span style="font-size:x-small;">    return x + 1</span></div>
<div class="lyx_code_item" id="magicparlabel-541"><span style="font-size:x-small;">def double_func(x):</span></div>
<div class="lyx_code_item" id="magicparlabel-542"><span style="font-size:x-small;">    return x * 2</span></div>
<div class="lyx_code_item" id="magicparlabel-543"><span style="font-size:x-small;">example_pipe = <b><span style="font-family:sans-serif;">make_pipeline</span></b><span style="font-family:monospace;">(</span></span></div>
<div class="lyx_code_item" id="magicparlabel-544"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">FunctionTransformer</span></b><span style="font-family:monospace;">(func = increment_func),</span></span></div>
<div class="lyx_code_item" id="magicparlabel-545"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">FunctionTransformer</span></b><span style="font-family:monospace;">(func = double_func)</span></span></div>
<div class="lyx_code_item" id="magicparlabel-546"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-547"><span style="font-size:x-small;">example_df = housing[["OverallQual", "GarageArea"]]</span></div>
<div class="lyx_code_item" id="magicparlabel-548"><span style="font-size:x-small;">example_pipe.fit(example_df)</span></div>
<div class="lyx_code_item" id="magicparlabel-549"><span style="font-size:x-small;">example_trafo = example_pipe.transform(example_df)</span></div>
<div class="lyx_code_item" id="magicparlabel-550"><span style="font-size:x-small;">display(example_df)</span></div>
<div class="lyx_code_item" id="magicparlabel-551"><span style="font-size:x-small;">display(example_trafo)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-552"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 22:  Test</span></div>
</div>
<div class="standard" id="magicparlabel-557">In the next subsection, we will explain pipelines and transformers in a broader context. </div>
<section>
<h4 class="subsubsection" id="magicparlabel-558"><span class="subsubsection_label">3.2.1</span> Terminology</h4>
<dl class="description">
<dt class="description_label">Features</dt>
<dd class="description_item" id="magicparlabel-559"> or <b>Attributes</b> are measurable properties of samples, although some samples may also have missing features.</dd>
<dt class="description_label">Targets</dt>
<dd class="description_item" id="magicparlabel-560"> are known properties in the in train sets, but usually unknown other datasets.</dd>
<dt class="description_label">Prediction Models</dt>
<dd class="description_item" id="magicparlabel-561"> in supervised learning tasks can predict targets based on their training and their train set. There are also unsupervised prediction models like cluster search models. Depending on whether the targets are numerical or categorical, prediction models are also called <b>regressors</b> or <b>classifiers</b>, respectively.</dd>
<dt class="description_label">Estimators</dt>
<dd class="description_item" id="magicparlabel-562"> are objects in <b><span style="font-size:x-small;">sklearn</span></b> that can train their internal prediction model with their <b><span style="font-size:x-small;">.fit</span></b><span style="font-size:x-small;">(<b>X, y</b>) </span>method (where <b><span style="font-size:x-small;">X </span></b>are the features and the targets <b><span style="font-size:x-small;">y</span></b> of the train set). Estimators also have the method <b><span style="font-size:x-small;">.predict</span></b><span style="font-size:x-small;">(...)</span> to predict unknown targets.</dd>
<dt class="description_label">Transformers</dt>
<dd class="description_item" id="magicparlabel-563"> are a bit similar to estimators, although <b><span style="font-size:x-small;">.fit</span></b><span style="font-size:x-small;">(...) </span>has a more general meaning in the sense that it adjusts its internal parameters to the input of <b><span style="font-size:x-small;">.fit</span></b><span style="font-size:x-small;">(...)</span> (a second argument is not needed here). Afterwards we can use the <b><span style="font-size:x-small;">.transform</span></b><span style="font-size:x-small;">(...)</span> method to return a transformed version of its argument. For the purpose of calling e.g. <b><span style="font-size:x-small;">trafo.fit</span></b><span style="font-size:x-small;">(<b>X</b>)</span> first and then <b><span style="font-size:x-small;">X = trafo.transform</span></b><span style="font-size:x-small;">(<b>X</b>),</span> we may use the shortcut <b><span style="font-size:x-small;">X = trafo.fit_transform</span></b><span style="font-size:x-small;">(<b>X</b>)</span> instead, which also has a faster computation speed. </dd>
<dt class="description_label">Pipelines</dt>
<dd class="description_item" id="magicparlabel-564"> are objects that contain a sequence of transformers, estimators or other existing pipelines (for nested pipelines). Each pipeline has a <b><span style="font-size:x-small;">.fit</span></b><span style="font-size:x-small;">(...)</span> method that accepts a single 2D container as input, which must be either a pandas.dataframe or 2D numpy.ndarray. This input is then passed to the argument of<b><span style="font-size:x-small;"> .fit_transform</span></b><span style="font-size:x-small;">(...)</span> of the first transformer in the pipeline. Afterwards the output of this <b><span style="font-size:x-small;">.fit_transform</span></b><span style="font-size:x-small;">(...)</span> is used for the input of the next transformer, etc. This process is repeated until the last element of the pipeline is reached, where only <b><span style="font-size:x-small;">.fit</span></b><span style="font-size:x-small;">(...)</span> is called. 
<br/>
Finally, the pipeline object exposes the methods of its last element, i.e. the pipeline has a <b><span style="font-size:x-small;">.transform</span></b><span style="font-size:x-small;">(...)</span> or <b><span style="font-size:x-small;">.predict</span></b><span style="font-size:x-small;">(...)</span> method depending on whether its last element is a transformer or estimator, respectively.</dd>
<dt class="description_label">Column Transformers</dt>
<dd class="description_item" id="magicparlabel-565"> are used to apply different transformers to selected sets of columns only. They are initialized by a list of 3-tuples, each of them representing a separate transformation. The first 3-tuple component is the string name of the transformation, the second component a transformer or even a whole pipeline, and the third component a list of feature labels for selecting the desired columns (in the case of 2D ndarrays these labels are integer indices).</dd>
</dl>
</section>
<section>
<h4 class="subsubsection" id="magicparlabel-566"><span class="subsubsection_label">3.2.2</span> Making predictions</h4>
<div class="standard" id="magicparlabel-567">Now we can take a look at the pipelines we are interested in. Here <b><span style="font-size:x-small;">make_pipeline</span></b> inserts the transformers in the piplines in the order it receives them in its argument list. E.g. the <b><span style="font-size:x-small;">target_trafo</span></b> pipeline (which will be applied to the house sale price sales later) first applies the <b><span style="font-size:x-small;">SimpleImputer</span></b> transformer, which replaces possibly missing values with the mean value of all available values in the column (see <b><span style="font-size:x-small;">strategy = "mean"</span></b>). Even if there are no missing values, we may sometimes require that the very first transformer returns a 2D numpy.ndarray, which can be more practical for the remaining transformers in the pipeline. In this case <b><span style="font-size:x-small;">SimpleImputer</span></b> transforms a dataframe into a 2D ndarray.</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-571">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-576"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-577"><span style="font-size:x-small;">target_trafo = <b><span style="font-family:sans-serif;">make_pipeline</span></b><span style="font-family:monospace;">(</span></span></div>
<div class="lyx_code_item" id="magicparlabel-578"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">SimpleImputer</span></b><span style="font-family:monospace;">(strategy = "mean", add_indicator=True),</span></span></div>
<div class="lyx_code_item" id="magicparlabel-579"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">FunctionTransformer</span></b><span style="font-family:monospace;">(func = np.log, inverse_func = np.exp),</span></span></div>
<div class="lyx_code_item" id="magicparlabel-580"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">StandardScaler</span></b><span style="font-family:monospace;">()</span></span></div>
<div class="lyx_code_item" id="magicparlabel-581"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-582"><span style="font-size:x-small;">feature_log_pipeline = <b><span style="font-family:sans-serif;">make_pipeline</span></b><span style="font-family:monospace;">(</span></span></div>
<div class="lyx_code_item" id="magicparlabel-583"><span style="font-size:x-small;">    SimpleImputer(strategy="mean"),</span></div>
<div class="lyx_code_item" id="magicparlabel-584"><span style="font-size:x-small;">    FunctionTransformer(func = np.log),</span></div>
<div class="lyx_code_item" id="magicparlabel-585"><span style="font-size:x-small;">    StandardScaler()</span></div>
<div class="lyx_code_item" id="magicparlabel-586"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-587"><span style="font-size:x-small;">feature_pipeline = <b><span style="font-family:sans-serif;">make_pipeline</span></b><span style="font-family:monospace;">(</span></span></div>
<div class="lyx_code_item" id="magicparlabel-588"><span style="font-size:x-small;">    SimpleImputer(strategy="mean"),</span></div>
<div class="lyx_code_item" id="magicparlabel-589"><span style="font-size:x-small;">    StandardScaler()</span></div>
<div class="lyx_code_item" id="magicparlabel-590"><span style="font-size:x-small;">)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-591"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 23:  Jupyter Cell</span></div>
</div>
<div class="standard" id="magicparlabel-596">Unlike for the transformation of features, we need to transform the targets back to their original form, i.e. an inverse transformation must be available. In <b><span style="font-size:x-small;">SimpleImputer</span></b> this is ensured by the argument <b><span style="font-size:x-small;">add_indicator=True</span></b>.</div>
<div class="standard" id="magicparlabel-597">Next we have the <b><span style="font-size:x-small;">FunctionTransformer</span></b> in the <b><span style="font-size:x-small;">target_trafo</span></b> pipeline. In our example it simply returns the logarithm of its input values. For now it suffices to know that this will help our linear regressor to make better predictions. This time we make sure the inverse transformation is available by adding the argument <b><span style="font-size:x-small;">inverse_func = np.exp</span></b>. </div>
<div class="standard" id="magicparlabel-598">The final transformer for our targets is <b><span style="font-size:x-small;">StandardScaler</span></b>, which centers the values around the mean of all values and scales it in a way that will improve the performance of our linear regressor. Otherwise unscaled values can become biased in favor of the available values on the whole scale instead of the actually occuring amount of values.</div>
<div class="standard" id="magicparlabel-599">In a similar fashion we define the other pipelines <b><span style="font-size:x-small;">feature_log_pipeline</span></b> and <b><span style="font-size:x-small;">feature_pipeline</span></b> for the features. Another way to use the function transformer is to define custom functions. In our case we want to be able to calculate the ratio of two columns. As mentioned earlier, it is possible to apply transformers on different columns separately, if we use column transformers.For the sake of simplicity, we ignore all other columns in the dataset (<b><span style="font-size:x-small;">remainder = "drop"</span></b>), although there are other options available to handle the remaining columns.</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-603">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-608"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-609"><span style="font-size:x-small;">def <b><span style="font-family:sans-serif;">column_ratio</span></b><span style="font-family:monospace;">(X):</span></span></div>
<div class="lyx_code_item" id="magicparlabel-610"><span style="font-size:x-small;">    return X[:,[0]] / X[:,[1]]</span></div>
<div class="lyx_code_item" id="magicparlabel-611"><span style="font-size:x-small;">feature_ratio = make_pipeline(</span></div>
<div class="lyx_code_item" id="magicparlabel-612"><span style="font-size:x-small;">    SimpleImputer(strategy="median"),</span></div>
<div class="lyx_code_item" id="magicparlabel-613"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">FunctionTransformer</span></b><span style="font-family:monospace;">(func = </span><b><span style="font-family:sans-serif;">column_ratio</span></b><span style="font-family:monospace;">),</span></span></div>
<div class="lyx_code_item" id="magicparlabel-614"><span style="font-size:x-small;">    StandardScaler()</span></div>
<div class="lyx_code_item" id="magicparlabel-615"><span style="font-size:x-small;">)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-616"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 24:  Jupyter Cell</span></div>
</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-624">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-629"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-630"><span style="font-size:x-small;">column_trafo = <b><span style="font-family:sans-serif;">ColumnTransformer</span></b><span style="font-family:monospace;">(</span></span></div>
<div class="lyx_code_item" id="magicparlabel-631"><span style="font-size:x-small;">    transformers = [</span></div>
<div class="lyx_code_item" id="magicparlabel-632"><span style="font-size:x-small;">        (’num_log’, feature_log_pipeline, ["GrLivArea"]),</span></div>
<div class="lyx_code_item" id="magicparlabel-633"><span style="font-size:x-small;">        (’ratio’, feature_ratio, ["BedroomAbvGr", "GrLivArea"]),</span></div>
<div class="lyx_code_item" id="magicparlabel-634"><span style="font-size:x-small;">        (’num’, feature_pipeline, ["OverallQual", "GarageArea"])</span></div>
<div class="lyx_code_item" id="magicparlabel-635"><span style="font-size:x-small;">    ],</span></div>
<div class="lyx_code_item" id="magicparlabel-636"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">remainder</span></b><span style="font-family:monospace;"> = "drop"</span></span></div>
<div class="lyx_code_item" id="magicparlabel-637"><span style="font-size:x-small;">)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-638"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 25:  Jupyter Cell</span></div>
</div>
<div class="standard" id="magicparlabel-643">An alternative to <b><span style="font-size:x-small;">make_pipeline</span></b> is the <b><span style="font-size:x-small;">Pipeline</span></b> class itself, which allows us to name each object in the pipeline manually. These names can play a role for the automatic optimization of so called <b>hyperparameters</b>, which are those parameters that cannot be adjusted by the prediction models during their training phase. However, we will not need to optimize any hyperparameter for this simple project.</div>
<div class="standard" id="magicparlabel-644">Finally we can combine our previous pipelines and our prediction model in a single pipeline.Afterwards we can assemble all pipelines in a single estimator. More precisely, this is called a <b>meta-estimator</b>, which enhances the functionality of normal estimators. Here the meta-estimator <b><span style="font-size:x-small;">TransformedTargetRegressor</span></b> automatically applies the inverse functions to the predicted targets. This is a bit less error-prone than applying each inverse function manually. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-648">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-653"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-654"><span style="font-size:x-small;">regressor_pipeline = <b><span style="font-family:sans-serif;">Pipeline</span></b><span style="font-family:monospace;">([</span></span></div>
<div class="lyx_code_item" id="magicparlabel-655"><span style="font-size:x-small;">    (’features’, column_trafo),</span></div>
<div class="lyx_code_item" id="magicparlabel-656"><span style="font-size:x-small;">    (’linear’, LinearRegression())</span></div>
<div class="lyx_code_item" id="magicparlabel-657"><span style="font-size:x-small;">])</span></div>
</div>
<div class="plain_layout" id="magicparlabel-658"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 26:  Jupyter Cell</span></div>
</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-666">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-671"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-672"><span style="font-size:x-small;">model = <b><span style="font-family:sans-serif;">TransformedTargetRegressor</span></b><span style="font-family:monospace;">(</span></span></div>
<div class="lyx_code_item" id="magicparlabel-673"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">transformer</span></b><span style="font-family:monospace;"> = target_trafo,</span></span></div>
<div class="lyx_code_item" id="magicparlabel-674"><span style="font-size:x-small;">    <b><span style="font-family:sans-serif;">regressor</span></b><span style="font-family:monospace;"> = regressor_pipeline</span></span></div>
<div class="lyx_code_item" id="magicparlabel-675"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-676"><span style="font-size:x-small;">model.fit(housing, housing_targets)</span></div>
<div class="lyx_code_item" id="magicparlabel-677"><span style="font-size:x-small;">housing_predicted_prices = model.<b><span style="font-family:sans-serif;">predict</span></b><span style="font-family:monospace;">(housing_final_test)</span></span></div>
</div>
<div class="plain_layout" id="magicparlabel-678"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 27:  Jupyter Cell</span></div>
</div>
<div class="standard" id="magicparlabel-683">Of course there are much more interesting meta-estimators like <b><span style="font-size:x-small;">RandomizedSearchCV</span></b> used for hyperparameter tuning, or meta-estimators used for mixing different types of estimators. </div>
<div class="standard" id="magicparlabel-684">In our simplified project the linear regressor is enough to make decent predictions. We store them in the <b><span style="font-size:x-small;">housing_predicted_prices</span></b> variable before measuring the RMSE with the test set. The resulting RMSE should be around 28 thousand dollars. Finally, we can create a <b><span style="font-size:x-small;">submission.csv</span></b> file that has the right format for submitting it on Kaggle. The final score should be below 0.20 (less means better), which is acceptable for such a small project. </div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-688">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-693"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-694"><span style="font-size:x-small;">from sklearn.metrics import root_mean_squared_error</span></div>
<div class="lyx_code_item" id="magicparlabel-695"><span style="font-size:x-small;">lin_rmse = <b><span style="font-family:sans-serif;">root_mean_squared_error</span></b><span style="font-family:monospace;">(</span></span></div>
<div class="lyx_code_item" id="magicparlabel-696"><span style="font-size:x-small;">    housing_targets_final_test, housing_predicted_prices</span></div>
<div class="lyx_code_item" id="magicparlabel-697"><span style="font-size:x-small;">)</span></div>
<div class="lyx_code_item" id="magicparlabel-698"><span style="font-size:x-small;">print((lin_rmse / 1e3).round(2), "thousand dollar RMSE for housing prices")</span></div>
</div>
<div class="plain_layout" id="magicparlabel-699"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 28:  Jupyter Cell</span></div>
</div>
<div class="float-algorithm"><div class="plain_layout" id="magicparlabel-707">
</div>
<div class="lyx_code">
<div class="lyx_code_item" id="magicparlabel-712"><span style="font-size:x-small;">#%% </span></div>
<div class="lyx_code_item" id="magicparlabel-713"><span style="font-size:x-small;">housing_predicted_prices = model.<b><span style="font-family:sans-serif;">predict</span></b><span style="font-family:monospace;">(housing_unknown)</span></span></div>
<div class="lyx_code_item" id="magicparlabel-714"><span style="font-size:x-small;">submission = pd.DataFrame({</span></div>
<div class="lyx_code_item" id="magicparlabel-715"><span style="font-size:x-small;">    ’Id’: housing_unknown[’Id’],</span></div>
<div class="lyx_code_item" id="magicparlabel-716"><span style="font-size:x-small;">    ’SalePrice’: housing_predicted_prices</span></div>
<div class="lyx_code_item" id="magicparlabel-717"><span style="font-size:x-small;">})</span></div>
<div class="lyx_code_item" id="magicparlabel-718"><span style="font-size:x-small;">submission.to_csv(sLocal_Folder_Path / ’submission.csv’, index=False)</span></div>
</div>
<div class="plain_layout" id="magicparlabel-719"><span class="float-caption-Standard float-caption float-caption-standard">Algorithm 29:  Jupyter Cell</span></div>
</div>
<div class="standard" id="magicparlabel-724">Before moving on, you can play around a little bit by removing the logarithm-transformations to see how the linear regressor performs. You can also replace it with another regressor like the <b><span style="font-size:x-small;">RandomForestRegressor</span></b>, where the performance does not depend very much on log-transformations or the standard scaler (except in extreme cases).</div>
<div class="standard" id="magicparlabel-725">Once you have understood the most important concepts in this small project, you can tackle the same problem with more sophisticated methods in the big project that comes next. This will give you a much better score and a deeper understanding of the problems occuring in machine learning.</div>
<h2 class="bibliography">References</h2>
<div class="bibliography">
<div class="bibliography" id="magicparlabel-726"><a id="LyXCite-Kaggle_Housing_Competition"></a><span class="bibitemlabel">Kaggle Housing</span><a href="https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/submissions">House Prices - Advanced Regression Techniques</a></div>
<div class="bibliography" id="magicparlabel-727"><a id="LyXCite-Install_Anaconda"></a><span class="bibitemlabel">AnacondaInstall</span><a href="https://github.com/ageron/handson-ml3/blob/main/INSTALL.md">https://github.com/ageron/handson-ml3/blob/main/INSTALL.md</a></div>
<div class="bibliography" id="magicparlabel-728"><a id="LyXCite-Geron_Colab"></a><span class="bibitemlabel">GeronColab</span><a href="https://colab.research.google.com/github/ageron/handson-ml3/blob/main/index.ipynb#scrollTo=-KAqK1NXk8Eu">https://colab.research.google.com/github/ageron/handson-ml3/blob/main/index.ipynb#scrollTo=-KAqK1NXk8Eu</a></div>
<div class="bibliography" id="magicparlabel-729"><a id="LyXCite-KagglData_py"></a><span class="bibitemlabel">1</span><a href="https://github.com/ynaghibi/BlogsResources/blob/main/KagglDataC1.py">https://github.com/ynaghibi/BlogsResources/blob/main/KagglDataC1.py</a></div>
<div class="bibliography" id="magicparlabel-730"><a id="LyXCite-HoML"></a><span class="bibitemlabel">HoML</span>Aurélien Géron (2019). <i>Hands-On Machine Learning with Scikit-Learn, Keras, and Tensorflow: Concepts, Tools, and Techniques to Build Intelligent Systems</i>. O’Reilly Media</div>
<div class="bibliography" id="magicparlabel-731"><a id="LyXCite-VanderPlas"></a><span class="bibitemlabel">VanderPlas</span>Jake VanderPlas (2016). <i>Python Data Science Handbook</i> O’Reilly Media</div>
<div class="bibliography" id="magicparlabel-732"><a id="LyXCite-Scrum"></a><span class="bibitemlabel">ScrumRef</span>Jeff Sutherland (2014). <i>Scrum: The Art of Doing Twice the Work in Half the Time</i>. Crown Currency</div>
</div></section>
</section>
</section>
</body>
</html>
